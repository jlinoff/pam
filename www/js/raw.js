// Print the records in plaintext top
/**
 * Print records in plaintext to allow users to store them
 * locally. This is not secure but it allows users to keep a hard
 * copy.
 */
import { xmk, xget, xgetn, enableFunctionChaining } from './lib.js'
import { statusBlip } from './status.js'
import { convertInternalDataToJSON } from './save.js'
import { loadCallback } from './load.js'
import { VERSION } from './version.js'  // automatically generated by make

export function enableRawJSONEdit() {
    let button = document.getElementById('x-edit-raw-json-data')
    if (window.prefs.enableRawJSONEdit) {
        button.xStyle({'display': 'block'})
    } else {
        button.xStyle({'display': 'none'})
    }
}

export function toggleRawJSONDataEdit() {
    // do nothing for now
    let div = document.getElementById('x-edit-raw-data-div')
    if (!!div) {
        removeRawEditPage()
    } else {
        mkRawEditPage()
    }
}

function removeRawEditPage() {
    let div = document.getElementById('x-edit-raw-data-div')
    div.remove()

    let topSection = document.getElementById('top-section')
    if (!!topSection) {
        topSection.xStyle({display: 'block'})
    }

    let midSection = document.getElementById('mid-section')
    if (!!midSection) {
        midSection.xStyle({display: 'block'})
    }

    // renable main page password generation
    let pgen = document.getElementById('x-generate-password')
    if (!!pgen ) {
        pgen.xStyle({display: 'block'})
    }

}

function mkRawEditPage() {
    // disable main page password generation to avoid overlay conflicts.
    let pgen = document.getElementById('x-generate-password')
    if (!!pgen ) {
        pgen.xStyle({display: 'none'})
    }

    let topSection = document.getElementById('top-section')
    if (!!topSection) {
        topSection.xStyle({display: 'none'})
    }

    let midSection = document.getElementById('mid-section')
    if (!!midSection) {
        midSection.xStyle({display: 'none'})
    }

    let now = new Date().toISOString()
    let contents = {
        'meta': {
            'date-saved': now,
            'format-version': VERSION,
        },
        'prefs': {},
        'records': [],
    }
    convertInternalDataToJSON(contents, now)
    let text = JSON.stringify(contents, null, 4)
    let numRows = estimateRowsForWindow() - 1

    let textarea = xmk('textarea')
        .xId('x-edit-raw-data-textarea')
        .xAttr('rows', numRows)
        .xStyle({'width': '100%',
                 'box-sizing': 'border-box',
                 'margin': '0',
                 'padding': '5px'})
    textarea.value = text

    let topDiv = xmk('div').xId('x-edit-raw-data-div')
        .xStyle({'padding-left':'1em',
                 'padding-right': '1em',
                 'padding-top':'0',
                 'margin-top': '0'})
        .xAppend(
            //xmk('p').xInnerHTML(text),
            textarea,
            xmk('div').xAppend(
                xmk('button')
                    .xClass('btn', 'btn-secondary', 'm-1')
                    .xAttrs({'title': 'save changes'})
                    .xInnerHTML('Close')
                    .xAddEventListener('click', (event) => { /* jshint ignore:line */
                        removeRawEditPage()
                        statusBlip('raw changes not saved')
                    }),
                xmk('button')
                    .xClass('btn', 'btn-secondary', 'm-1')
                    .xAttrs({'title': 'save changes'})
                    .xInnerHTML('Save')
                    .xAddEventListener('click', (event) => { /* jshint ignore:line */
                        let ta = document.getElementById('x-edit-raw-data-textarea')
                        loadCallback(ta.value)
                        statusBlip('raw changes saved')
                        removeRawEditPage()
                    }),
            ),
            xmk('div').xStyle({'height': '80px'}) // for scrolling over footer
        )
    document.body.appendChild(topDiv)
}

// This code was written by Gemini 2.5.
function estimateRowsForWindow(footerSelector = 'footer') {
    // 1. Get the total available height of the browser's viewport.
    const windowHeight = window.innerHeight

    // 2. Find the footer element using the provided selector.
    const footerElement = document.querySelector(footerSelector)

    // 3. Measure the footer's height. If it doesn't exist, its height is 0.
    let footerHeight = 0
    if (footerElement) {
        // offsetHeight includes padding and border, which is what we want.
        footerHeight = footerElement.offsetHeight
    }

    // 4. Calculate the usable height for the textarea.
    const usableHeight = windowHeight - footerHeight

    // 5. Create a temporary textarea to measure its default line-height.
    const tempTextarea = document.createElement('textarea')
    tempTextarea.style.position = 'absolute'
    tempTextarea.style.visibility = 'hidden'
    tempTextarea.style.top = '-9999px'
    document.body.appendChild(tempTextarea)

    // 6. Get the computed line-height.
    const computedStyle = window.getComputedStyle(tempTextarea)
    const lineHeight = parseFloat(computedStyle.lineHeight)

    // 7. Clean up by removing the temporary element.
    document.body.removeChild(tempTextarea)

    // 8. Calculate the number of rows based on the usable height.
    if (isNaN(lineHeight) || lineHeight <= 0 || usableHeight <= 0) {
        return 0 // Return 0 if there's no space or if measurement failed.
    }

    const numberOfRows = Math.floor(usableHeight / lineHeight)

    return numberOfRows;
}
